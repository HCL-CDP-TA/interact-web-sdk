{"version":3,"sources":["../src/InteractClient.ts","../src/InteractError.ts","../src/InteractServletClient.ts"],"sourcesContent":["// HCL Interact SDK - Servlet API Compatible\n// Clean, opinionated TypeScript client with React integration\n\nexport interface InteractConfig {\n  serverUrl: string // e.g., \"https://your-server.com/interact\"\n  interactiveChannel?: string // defaults to \"_RealTimePersonalization_\"\n  username?: string\n  password?: string\n  enableLogging?: boolean\n}\n\nexport interface AudienceConfig {\n  audienceLevel: \"Visitor\" | \"Customer\" | string\n  audienceId: {\n    name: string\n    value: string | number\n    type: \"string\" | \"numeric\" | \"datetime\"\n  }\n}\n\nexport interface AudienceConfig {\n  audienceLevel: \"Visitor\" | \"Customer\" | string\n  audienceId: {\n    name: string\n    value: string | number\n    type: \"string\" | \"numeric\" | \"datetime\"\n  }\n}\n\nexport interface SessionState {\n  sessionId: string | null\n  isValid: boolean\n  lastActivity: Date\n}\n\nexport interface InteractMessage {\n  msg: string\n  detailMsg: string\n  msgLevel: number\n  msgCode: number\n}\n\nexport interface NameValuePair {\n  n: string\n  v: any\n  t: \"string\" | \"numeric\" | \"datetime\"\n}\n\nexport interface Command {\n  action: string\n  ic?: string // interactive channel\n  audienceID?: NameValuePair[] // array of name/value/type objects\n  audienceLevel?: string\n  parameters?: NameValuePair[]\n  relyOnExistingSession?: boolean\n  debug?: boolean\n  ip?: string // interaction point\n  numberRequested?: number\n  event?: string\n  getOfferRequests?: any[]\n}\n\nexport interface OfferAttribute {\n  n: string // name\n  v: any // value\n  t: string // type\n}\n\nexport interface Offer {\n  n: string // offer name\n  code: string[] // offer codes (array)\n  treatmentCode: string\n  score: number\n  desc: string // description\n  attributes: OfferAttribute[]\n}\n\nexport interface OfferList {\n  interactionPointName: string\n  defaultString: string\n  offers: Offer[]\n}\n\nexport interface InteractResponse {\n  sessionId?: string\n  statusCode: number\n  offerLists?: OfferList[]\n  profile?: NameValuePair[]\n  version?: string\n  messages?: InteractMessage[]\n}\n\nexport interface BatchResponse {\n  batchStatusCode: number\n  responses: InteractResponse[]\n}\n\nexport class InteractClient {\n  private config: InteractConfig\n  private tokenId: string | null = null\n  private sessionState: SessionState = {\n    sessionId: null,\n    isValid: false,\n    lastActivity: new Date(),\n  }\n\n  constructor(config: InteractConfig) {\n    this.config = {\n      ...config,\n      interactiveChannel: config.interactiveChannel || \"_RealTimePersonalization_\",\n    }\n  }\n\n  // Helper to convert AudienceConfig to NameValuePair array\n  private convertAudienceToArray(audience: AudienceConfig): NameValuePair[] {\n    return [\n      {\n        n: audience.audienceId.name,\n        v: audience.audienceId.value,\n        t: audience.audienceId.type,\n      },\n    ]\n  }\n\n  // Public helper for users who need to create audience arrays manually\n  static convertAudienceToArray(audience: AudienceConfig): NameValuePair[] {\n    return [\n      {\n        n: audience.audienceId.name,\n        v: audience.audienceId.value,\n        t: audience.audienceId.type,\n      },\n    ]\n  }\n\n  // Session management methods\n  getSessionId(): string | null {\n    return this.sessionState.sessionId\n  }\n\n  setSessionId(sessionId: string | null): void {\n    this.sessionState.sessionId = sessionId\n    this.sessionState.isValid = !!sessionId\n    this.sessionState.lastActivity = new Date()\n  }\n\n  isSessionValid(): boolean {\n    return this.sessionState.isValid && !!this.sessionState.sessionId\n  }\n\n  clearSession(): void {\n    this.sessionState = {\n      sessionId: null,\n      isValid: false,\n      lastActivity: new Date(),\n    }\n  }\n\n  // Helper methods for default audience configurations\n  static createVisitorAudience(visitorId: string = \"0\"): AudienceConfig {\n    return {\n      audienceLevel: \"Visitor\",\n      audienceId: {\n        name: \"VisitorID\",\n        value: visitorId,\n        type: \"string\",\n      },\n    }\n  }\n\n  static createCustomerAudience(customerId: number): AudienceConfig {\n    return {\n      audienceLevel: \"Customer\",\n      audienceId: {\n        name: \"CustomerID\",\n        value: customerId,\n        type: \"numeric\",\n      },\n    }\n  }\n\n  // Check if response indicates session is invalid\n  private isSessionInvalid(response: BatchResponse): boolean {\n    return (\n      response.responses?.some(\n        r =>\n          r.statusCode === 2 &&\n          r.messages?.some(m => m.msgLevel === 2 && m.msg.toLowerCase().includes(\"invalid session id\")),\n      ) || false\n    )\n  }\n\n  // Execute batch with automatic session retry\n  async executeBatchWithRetry(\n    sessionId: string | null,\n    commands: Command[],\n    audience?: AudienceConfig,\n    maxRetries: number = 1,\n  ): Promise<BatchResponse> {\n    let currentSessionId = sessionId || this.sessionState.sessionId\n    let attempt = 0\n\n    while (attempt <= maxRetries) {\n      try {\n        const response = await this.executeBatch(currentSessionId, commands)\n\n        // Update session ID if returned\n        if (response.responses?.[0]?.sessionId) {\n          this.setSessionId(response.responses[0].sessionId)\n        }\n\n        // Check if session is invalid\n        if (this.isSessionInvalid(response) && attempt < maxRetries) {\n          if (this.config.enableLogging) {\n            console.warn(\"Session invalid, retrying with new session...\")\n          }\n\n          // Clear invalid session\n          this.clearSession()\n\n          // If we have audience config, start a new session\n          if (audience) {\n            const newSessionResponse = await this.startSessionLowLevel(\n              null,\n              this.convertAudienceToArray(audience),\n              audience.audienceLevel,\n            )\n\n            if (newSessionResponse.sessionId) {\n              currentSessionId = newSessionResponse.sessionId\n              this.setSessionId(currentSessionId)\n\n              // Retry the original commands with new session\n              attempt++\n              continue\n            }\n          }\n\n          throw new Error(\"Failed to establish new session after invalid session\")\n        }\n\n        return response\n      } catch (error) {\n        if (attempt >= maxRetries) {\n          throw error\n        }\n        attempt++\n      }\n    }\n\n    throw new Error(\"Max retries exceeded\")\n  }\n\n  // Core batch execution - the main method for all API calls\n  async executeBatch(sessionId: string | null, commands: Command[]): Promise<BatchResponse> {\n    const url = `${this.config.serverUrl}/servlet/RestServlet`\n\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json; charset=utf-8\",\n    }\n\n    // Handle authentication\n    if (this.tokenId) {\n      headers[\"m_tokenId\"] = this.tokenId\n    } else if (this.config.username) {\n      headers[\"m_user_name\"] = encodeURIComponent(this.config.username)\n      headers[\"m_user_password\"] = encodeURIComponent(this.config.password || \"\")\n    }\n\n    // Build request body - only include sessionId if it's not null\n    const requestBody: any = {\n      commands: commands,\n    }\n\n    // Only include sessionId if we have one, let server generate one if null\n    if (sessionId !== null) {\n      requestBody.sessionId = sessionId\n    }\n\n    const requestBodyString = JSON.stringify(requestBody)\n\n    if (this.config.enableLogging) {\n      console.log(\"Interact Request:\", requestBodyString)\n    }\n\n    try {\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers,\n        body: requestBodyString,\n      })\n\n      // Handle token response\n      const responseTokenId = response.headers.get(\"m_tokenId\")\n      if (responseTokenId) {\n        this.tokenId = responseTokenId\n      }\n\n      const responseData = await response.json()\n\n      if (response.status === 200) {\n        if (this.config.enableLogging) {\n          console.log(\"Interact Response:\", responseData)\n        }\n        return responseData\n      } else {\n        throw new Error(`Interact API error: ${response.status}`)\n      }\n    } catch (error) {\n      if (this.config.enableLogging) {\n        console.error(\"Interact API error:\", error)\n      }\n      throw error\n    }\n  }\n\n  // Convenience methods for common operations\n  // Low-level session start with full control\n  async startSessionLowLevel(\n    sessionId: string | null,\n    audienceID: NameValuePair[],\n    audienceLevel: string,\n    parameters?: NameValuePair[],\n    relyOnExistingSession: boolean = true,\n    debug: boolean = false,\n  ): Promise<InteractResponse> {\n    const commands: Command[] = [\n      {\n        action: \"startSession\",\n        ic: this.config.interactiveChannel,\n        audienceID,\n        audienceLevel,\n        parameters,\n        relyOnExistingSession,\n        debug,\n      },\n    ]\n\n    const batchResponse = await this.executeBatch(sessionId, commands)\n    return this.extractFirstResponse(batchResponse)\n  }\n\n  // Main session start method with audience config and optional sessionId\n  async startSession(audience: AudienceConfig, sessionId?: string | null): Promise<InteractResponse> {\n    const audienceIdArray = this.convertAudienceToArray(audience)\n    const response = await this.startSessionLowLevel(sessionId ?? null, audienceIdArray, audience.audienceLevel)\n\n    if (response.sessionId) {\n      this.setSessionId(response.sessionId)\n    }\n\n    return response\n  }\n\n  async getOffers(sessionId: string, interactionPoint: string, numberRequested: number = 1): Promise<InteractResponse> {\n    const commands: Command[] = [\n      {\n        action: \"getOffers\",\n        ip: interactionPoint,\n        numberRequested,\n      },\n    ]\n\n    const batchResponse = await this.executeBatch(sessionId, commands)\n    return this.extractFirstResponse(batchResponse)\n  }\n\n  // Method overloads for postEvent - provides multiple call signatures\n  async postEvent(sessionId: string, eventName: string, parameters?: NameValuePair[]): Promise<InteractResponse>\n  async postEvent(\n    eventName: string,\n    parameters?: NameValuePair[],\n    options?: {\n      sessionId?: string\n      autoManageSession?: boolean\n      audience?: AudienceConfig\n    },\n  ): Promise<InteractResponse>\n\n  // Implementation handles both signatures\n  async postEvent(\n    sessionIdOrEventName: string,\n    eventNameOrParameters?: string | NameValuePair[],\n    parametersOrOptions?:\n      | NameValuePair[]\n      | {\n          sessionId?: string\n          autoManageSession?: boolean\n          audience?: AudienceConfig\n        },\n  ): Promise<InteractResponse> {\n    // Detect which overload was called based on parameter types\n    if (typeof eventNameOrParameters === \"string\") {\n      // Old signature: postEvent(sessionId, eventName, parameters?)\n      const sessionId = sessionIdOrEventName\n      const eventName = eventNameOrParameters\n      const parameters = parametersOrOptions as NameValuePair[] | undefined\n\n      const commands: Command[] = [\n        {\n          action: \"postEvent\",\n          event: eventName,\n          parameters,\n        },\n      ]\n\n      const batchResponse = await this.executeBatch(sessionId, commands)\n      return this.extractFirstResponse(batchResponse)\n    } else {\n      // New signature: postEvent(eventName, parameters?, options?)\n      const eventName = sessionIdOrEventName\n      const parameters = eventNameOrParameters as NameValuePair[] | undefined\n      const options = parametersOrOptions as\n        | {\n            sessionId?: string\n            autoManageSession?: boolean\n            audience?: AudienceConfig\n          }\n        | undefined\n\n      const { sessionId: explicitSessionId, autoManageSession = false, audience } = options || {}\n\n      let sessionId: string | undefined = explicitSessionId\n\n      if (!sessionId) {\n        if (autoManageSession) {\n          // Auto-managed session mode\n          sessionId = this.getSessionId() || undefined\n\n          if (!sessionId && audience) {\n            const sessionResponse = await this.startSession(audience)\n            sessionId = sessionResponse.sessionId || undefined\n          }\n\n          if (!sessionId) {\n            throw new Error(\"No session available and no audience provided to start new session\")\n          }\n\n          const commands: Command[] = [\n            {\n              action: \"postEvent\",\n              event: eventName,\n              parameters,\n            },\n          ]\n\n          const batchResponse = await this.executeBatchWithRetry(sessionId, commands, audience)\n          return this.extractFirstResponse(batchResponse)\n        } else {\n          throw new Error(\"No sessionId provided and autoManageSession not enabled\")\n        }\n      }\n\n      // Manual session mode\n      const commands: Command[] = [\n        {\n          action: \"postEvent\",\n          event: eventName,\n          parameters,\n        },\n      ]\n\n      const batchResponse = await this.executeBatch(sessionId, commands)\n      return this.extractFirstResponse(batchResponse)\n    }\n  }\n\n  async getVersion(): Promise<InteractResponse> {\n    const commands: Command[] = [\n      {\n        action: \"getVersion\",\n      },\n    ]\n\n    const batchResponse = await this.executeBatch(null, commands)\n    return this.extractFirstResponse(batchResponse)\n  }\n\n  async endSession(sessionId: string): Promise<InteractResponse> {\n    const commands: Command[] = [\n      {\n        action: \"endSession\",\n      },\n    ]\n\n    const batchResponse = await this.executeBatch(sessionId, commands)\n    return this.extractFirstResponse(batchResponse)\n  }\n\n  async setAudience(sessionId: string, audienceID: NameValuePair[], audienceLevel?: string): Promise<InteractResponse> {\n    const commands: Command[] = [\n      {\n        action: \"setAudience\",\n        audienceID,\n        audienceLevel,\n      },\n    ]\n\n    const batchResponse = await this.executeBatch(sessionId, commands)\n    const response = this.extractFirstResponse(batchResponse)\n\n    // Update the current session ID if the command was successful\n    if (response.sessionId) {\n      this.setSessionId(response.sessionId)\n    }\n\n    return response\n  }\n\n  async setAudienceFromConfig(\n    sessionId: string,\n    audience: AudienceConfig,\n    audienceLevel?: string,\n  ): Promise<InteractResponse> {\n    const audienceIdArray = this.convertAudienceToArray(audience)\n    return this.setAudience(sessionId, audienceIdArray, audienceLevel)\n  }\n\n  // Batch builder for complex workflows\n  createBatch(): BatchBuilder {\n    return new BatchBuilder(this)\n  }\n\n  // Enhanced convenience methods with automatic session management\n  async getOffersWithSession(\n    interactionPoint: string,\n    numberRequested: number = 1,\n    audience?: AudienceConfig,\n  ): Promise<InteractResponse> {\n    let sessionId = this.getSessionId()\n\n    // If no session, start one\n    if (!sessionId && audience) {\n      const sessionResponse = await this.startSession(audience)\n      sessionId = sessionResponse.sessionId || null\n    }\n\n    if (!sessionId) {\n      throw new Error(\"No session available and no audience provided to start new session\")\n    }\n\n    const commands: Command[] = [\n      {\n        action: \"getOffers\",\n        ip: interactionPoint,\n        numberRequested,\n      },\n    ]\n\n    const batchResponse = await this.executeBatchWithRetry(sessionId, commands, audience)\n    return this.extractFirstResponse(batchResponse)\n  }\n\n  // Backward compatibility wrapper for postEventWithSession\n  async postEventWithSession(\n    eventName: string,\n    parameters?: NameValuePair[],\n    audience?: AudienceConfig,\n  ): Promise<InteractResponse> {\n    return this.postEvent(eventName, parameters, { autoManageSession: true, audience })\n  }\n\n  // Complete workflow methods\n  async getOffersForPage(\n    interactionPoint: string,\n    audience: AudienceConfig,\n    numberRequested: number = 1,\n    trackPageView: boolean = true,\n  ): Promise<{ offers: Offer[]; sessionId: string }> {\n    const batch = this.createBatch()\n\n    // Always start with session\n    const audienceIdArray = this.convertAudienceToArray(audience)\n    batch.startSession(audienceIdArray, audience.audienceLevel)\n\n    // Track page view if requested\n    if (trackPageView) {\n      batch.postEvent(\"page_view\")\n    }\n\n    // Get offers\n    batch.getOffers(interactionPoint, numberRequested)\n\n    const results = await batch.execute(null)\n\n    // Extract session ID and offers\n    const sessionId = results.responses?.[0]?.sessionId\n    if (sessionId) {\n      this.setSessionId(sessionId)\n    }\n\n    const offersResponse = results.responses?.find(r => r.offerLists && r.offerLists.length > 0)\n    const offers = offersResponse?.offerLists?.[0]?.offers || []\n\n    return {\n      offers,\n      sessionId: sessionId || this.getSessionId() || \"\",\n    }\n  }\n\n  // Helper methods\n  static createParameter(name: string, value: any, type: \"string\" | \"numeric\" | \"datetime\" = \"string\"): NameValuePair {\n    return { n: name, v: value, t: type }\n  }\n\n  private extractFirstResponse(batchResponse: BatchResponse): InteractResponse {\n    if (batchResponse.responses && batchResponse.responses.length >= 1) {\n      return batchResponse.responses[0]\n    }\n    throw new Error(\"No response in batch\")\n  }\n}\n\n// Fluent batch builder for complex workflows\nexport class BatchBuilder {\n  private client: InteractClient\n  private commands: Command[] = []\n\n  constructor(client: InteractClient) {\n    this.client = client\n  }\n\n  startSession(\n    audienceID: NameValuePair[],\n    audienceLevel: string,\n    parameters?: NameValuePair[],\n    relyOnExistingSession: boolean = true,\n    debug: boolean = false,\n  ): BatchBuilder {\n    this.commands.push({\n      action: \"startSession\",\n      ic: this.client[\"config\"].interactiveChannel,\n      audienceID,\n      audienceLevel,\n      parameters,\n      relyOnExistingSession,\n      debug,\n    })\n    return this\n  }\n\n  getOffers(interactionPoint: string, numberRequested: number = 1): BatchBuilder {\n    this.commands.push({\n      action: \"getOffers\",\n      ip: interactionPoint,\n      numberRequested,\n    })\n    return this\n  }\n\n  postEvent(eventName: string, parameters?: NameValuePair[]): BatchBuilder {\n    this.commands.push({\n      action: \"postEvent\",\n      event: eventName,\n      parameters,\n    })\n    return this\n  }\n\n  endSession(): BatchBuilder {\n    this.commands.push({\n      action: \"endSession\",\n    })\n    return this\n  }\n\n  setAudience(audienceID: NameValuePair[], audienceLevel?: string): BatchBuilder {\n    this.commands.push({\n      action: \"setAudience\",\n      audienceID,\n      audienceLevel,\n    })\n    return this\n  }\n\n  async execute(sessionId: string | null): Promise<BatchResponse> {\n    const result = await this.client.executeBatch(sessionId, this.commands)\n    this.commands = [] // Reset for reuse\n    return result\n  }\n}\n","export default class InteractApiError extends Error {\n  constructor(public status: number, public statusText: string, message?: string) {\n    super(message || `API Error: ${status} ${statusText}`)\n    this.name = \"InteractApiError\"\n  }\n}\n","// Servlet Interact API Client\n// Compatible with the original interactapi.js servlet-based API\nimport InteractApiError from \"./InteractError.js\"\n\nexport interface ServletApiConfig {\n  url: string // Base URL to the server (e.g., \"https://yourserver.com/interact\")\n  m_user_name?: string\n  m_user_password?: string\n  enableLog?: string // \"true\" to enable logging\n}\n\nexport interface NameValuePair {\n  n: string // name\n  v: any // value\n  t: string // type: \"string\", \"numeric\", \"datetime\"\n}\n\nexport interface Command {\n  action: string\n  ic?: string // interactive channel\n  audienceID?: string\n  audienceLevel?: string\n  parameters?: NameValuePair[]\n  relyOnExistingSession?: boolean\n  debug?: boolean\n  ip?: string // interaction point\n  numberRequested?: number\n  event?: string\n  getOfferRequests?: any[]\n}\n\nexport interface ServletResponse {\n  sessionId?: string\n  statusCode: number\n  offerLists?: any[]\n  profile?: NameValuePair[]\n  version?: string\n  messages?: any[]\n}\n\nexport interface ServletBatchResponse {\n  batchStatusCode: number\n  responses: ServletResponse[]\n}\n\nexport interface ServletCallback {\n  successCb?: (response: ServletResponse) => void\n  failureCb?: (error: any) => void\n}\n\nexport class InteractServletClient {\n  private config: ServletApiConfig\n\n  constructor(config: ServletApiConfig) {\n    this.config = config\n  }\n\n  // Core execute command method that mimics the original interactapi.js\n  private async executeCmd(requestBody: string): Promise<any> {\n    const url = this.config.url + \"/servlet/RestServlet\"\n\n    const headers: Record<string, string> = {\n      \"Content-type\": \"application/json; charset=utf-8\",\n    }\n\n    // Check for token in cookie (simplified - in browser this would use document.cookie)\n    const tokenId = this.getTokenFromCookie(\"m_tokenId\")\n    if (tokenId) {\n      headers[\"m_tokenId\"] = tokenId\n    } else if (this.config.m_user_name) {\n      headers[\"m_user_name\"] = encodeURIComponent(this.config.m_user_name)\n      headers[\"m_user_password\"] = encodeURIComponent(this.config.m_user_password || \"\")\n    }\n\n    if (this.config.enableLog === \"true\") {\n      console.log(\"Executing commands: \" + requestBody)\n    }\n\n    try {\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers,\n        body: requestBody,\n      })\n\n      // Handle token response header (simplified)\n      const responseTokenId = response.headers.get(\"m_tokenId\")\n      if (responseTokenId) {\n        this.setTokenCookie(\"m_tokenId\", responseTokenId, requestBody.indexOf(\"endSession\") > -1)\n      }\n\n      let responseData: any\n      const responseText = await response.text()\n\n      try {\n        responseData = JSON.parse(responseText)\n      } catch (e) {\n        responseData = responseText\n      }\n\n      if (response.status === 200) {\n        if (this.config.enableLog === \"true\") {\n          console.log(\"Response: \" + responseText)\n        }\n        return responseData\n      } else {\n        if (this.config.enableLog === \"true\") {\n          console.error(\"Response: \" + responseText)\n        }\n        throw new InteractApiError(response.status, response.statusText, `Request failed: ${response.status}`)\n      }\n    } catch (error) {\n      throw error\n    }\n  }\n\n  // Execute batch commands - this is the main method matching the original API\n  async executeBatch(sessionId: string | null, commands: Command[]): Promise<ServletBatchResponse> {\n    const requestBody = JSON.stringify({\n      sessionId: sessionId,\n      commands: commands,\n    })\n\n    return this.executeCmd(requestBody)\n  }\n\n  // Convenience methods that match the original interactapi.js API\n\n  async getVersion(): Promise<ServletResponse> {\n    const commands = [this.createGetVersionCmd()]\n    const batchResponse = await this.executeBatch(null, commands)\n    return this.extractFirstResponse(batchResponse)\n  }\n\n  async startSession(\n    sessionId: string | null,\n    ic: string,\n    audienceID: string,\n    audienceLevel: string,\n    parameters?: NameValuePair[],\n    relyOnExistingSession?: boolean,\n    debug?: boolean,\n  ): Promise<ServletResponse> {\n    const commands = [\n      this.createStartSessionCmd(ic, audienceID, audienceLevel, parameters, relyOnExistingSession, debug),\n    ]\n    const batchResponse = await this.executeBatch(sessionId, commands)\n    return this.extractFirstResponse(batchResponse)\n  }\n\n  async getOffers(sessionId: string, ip: string, numberRequested: number): Promise<ServletResponse> {\n    const commands = [this.createGetOffersCmd(ip, numberRequested)]\n    const batchResponse = await this.executeBatch(sessionId, commands)\n    return this.extractFirstResponse(batchResponse)\n  }\n\n  async endSession(sessionId: string): Promise<ServletResponse> {\n    const commands = [this.createEndSessionCmd()]\n    const batchResponse = await this.executeBatch(sessionId, commands)\n    return this.extractFirstResponse(batchResponse)\n  }\n\n  async getProfile(sessionId: string): Promise<ServletResponse> {\n    const commands = [this.createGetProfileCmd()]\n    const batchResponse = await this.executeBatch(sessionId, commands)\n    return this.extractFirstResponse(batchResponse)\n  }\n\n  async postEvent(sessionId: string, event: string, parameters?: NameValuePair[]): Promise<ServletResponse> {\n    const commands = [this.createPostEventCmd(event, parameters)]\n    const batchResponse = await this.executeBatch(sessionId, commands)\n    return this.extractFirstResponse(batchResponse)\n  }\n\n  // Command builders that match the original CommandUtil\n  private createGetVersionCmd(): Command {\n    return { action: \"getVersion\" }\n  }\n\n  private createEndSessionCmd(): Command {\n    return { action: \"endSession\" }\n  }\n\n  private createStartSessionCmd(\n    ic: string,\n    audienceID: string,\n    audienceLevel: string,\n    parameters?: NameValuePair[],\n    relyOnExistingSession?: boolean,\n    debug?: boolean,\n  ): Command {\n    const cmd: Command = {\n      action: \"startSession\",\n      ic: ic,\n      audienceID: audienceID,\n      audienceLevel: audienceLevel,\n      relyOnExistingSession: relyOnExistingSession,\n      debug: debug,\n    }\n    if (parameters) {\n      cmd.parameters = parameters\n    }\n    return cmd\n  }\n\n  private createGetOffersCmd(ip: string, numberRequested: number): Command {\n    return {\n      action: \"getOffers\",\n      ip: ip,\n      numberRequested: numberRequested,\n    }\n  }\n\n  private createGetProfileCmd(): Command {\n    return { action: \"getProfile\" }\n  }\n\n  private createPostEventCmd(event: string, parameters?: NameValuePair[]): Command {\n    const cmd: Command = {\n      action: \"postEvent\",\n      event: event,\n    }\n    if (parameters) {\n      cmd.parameters = parameters\n    }\n    return cmd\n  }\n\n  // Helper to extract first response from batch (matching FirstResponseCallback behavior)\n  private extractFirstResponse(batchResponse: ServletBatchResponse): ServletResponse {\n    if (batchResponse.responses && batchResponse.responses.length >= 1) {\n      return batchResponse.responses[0]\n    }\n    throw new InteractApiError(0, \"No response in batch\")\n  }\n\n  // Utility to create name-value pairs\n  static createParameter(name: string, value: any, type: \"string\" | \"numeric\" | \"datetime\" = \"string\"): NameValuePair {\n    return { n: name, v: value, t: type }\n  }\n\n  // Simplified cookie handling (in real browser environment, this would use document.cookie)\n  private getTokenFromCookie(name: string): string | null {\n    // In a real implementation, this would parse document.cookie\n    // For now, return null to fall back to username/password auth\n    return null\n  }\n\n  private setTokenCookie(name: string, value: string, endSession: boolean): void {\n    // In a real implementation, this would set document.cookie\n    // For now, we'll skip cookie management\n  }\n}\n"],"mappings":"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","names":["commands","batchResponse"]}